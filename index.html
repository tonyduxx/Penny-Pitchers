<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rent Due ‚Äî Penny Pinchers</title>
<style>
  :root{
    --bg:#0f1220;
    --ink:#e9ecf2;
    --accent:#72ffa6;
    --accent-2:#7cc3ff;
    --bad:#ff6b6b;
    --warn:#ffd166;
    --jar:#47d16a;
    --panel:#171b30;
    --panel-2:#111425;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 60% 15%, #1a2040 0%, #0c0f1c 60%, #080a14 100%); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";}

  .wrap{
    max-width: 980px;
    margin: 0 auto;
    padding: 14px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  header{
    display:flex; align-items:center; justify-content:space-between; gap:12px;
  }
  h1{
    margin:0; font-weight:800; letter-spacing:.5px;
    font-size: clamp(18px, 2.6vw, 28px);
    display:flex; align-items:center; gap:10px;
  }
  h1 .tag {font-size:.78em; font-weight:700; padding:4px 9px; border-radius:999px; background:linear-gradient(180deg,var(--panel),var(--panel-2)); border:1px solid #22263f; color:#9ab;}
  .controls{
    display:flex; gap:8px; flex-wrap:wrap;
  }
  button, .toggle{
    background: linear-gradient(180deg,#1b2143,#141a36);
    border: 1px solid #2a2f57; color:#e9ecf2;
    padding:10px 14px; border-radius:12px; font-weight:700;
    cursor:pointer; outline:none;
    box-shadow: 0 1px 0 #000 inset, 0 0 0 0 rgba(0,0,0,.2);
    transform: translateZ(0);
  }
  button:hover{filter:brightness(1.08)}
  button.primary{background:linear-gradient(180deg,#2c865a,#1c6f49); border-color:#2b9c68}
  button.warn{background:linear-gradient(180deg,#7a1f1f,#611515); border-color:#9c3838}
  .hud{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    background:linear-gradient(180deg,var(--panel),var(--panel-2));
    border:1px solid #252a4a; padding:10px 12px; border-radius:14px;
  }
  .pill{
    padding:6px 10px; border-radius:999px; background:#0e1226; border:1px solid #23284a; color:#c8d2eb; font-weight:700; letter-spacing:.2px;
  }
  .meter{
    flex:1 1 280px; background:#0b0f22; border:1px solid #1e2444; border-radius:10px; height:14px; position:relative; overflow:hidden;
  }
  .meter>span{position:absolute; left:0; top:0; bottom:0; background:linear-gradient(90deg,#34d399,#22c55e); width:0%;}
  .meter .label{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:12px; color:#a8b2d8; pointer-events:none; mix-blend-mode:screen}

  canvas{
    width:100%; height:auto; border-radius:16px;
    background: linear-gradient(180deg, #0b1025, #090d1e 38%, #070a16);
    border:1px solid #222647; box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 120px rgba(21,28,64,.6);
    touch-action:none;
  }

  .help{
    font-size:14px; color:#b7c1e0;
    background:linear-gradient(180deg,var(--panel),var(--panel-2));
    border:1px solid #252a4a; padding:10px 12px; border-radius:14px;
  }

  .kbd{padding:2px 6px;border-radius:6px;background:#0c1030;border:1px solid #293059;font-weight:800}

  .watermark{
    position:fixed; right:12px; bottom:10px; opacity:.45; font-weight:800; letter-spacing:.8px; font-size:12px;
  }

  @media (max-width:560px){
    .controls{gap:6px}
    button{padding:8px 10px}
    .hud{gap:6px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ü™ô Rent Due <span class="tag">Coin Flip Frenzy</span></h1>
      <!-- Player selection UI -->
      <div class="controls" style="margin-bottom:10px;">
        <label for="playerSelect" style="font-weight:700;">Choose Roommate:</label>
        <select id="playerSelect" style="font-weight:700; padding:6px 10px; border-radius:8px;">
          <option value="danny_coin_drop.png">Danny</option>
          <option value="trey_coin_drop.png">Trey</option>
          <option value="black_coin_drop.png">Black</option>
        </select>
      </div>
      <div class="controls">
        <button id="btnStart" class="primary">‚ñ∂ Start</button>
        <button id="btnDrop">ü™ô Drop (<span id="hotkey">Space</span>)</button>
        <button id="btnReset" class="warn">‚ü≤ Reset</button>
        <button id="btnMute" class="toggle">üîä Sound: On</button>
      </div>
    </header>

    <div class="hud">
      <span class="pill">Coins left: <b id="coinsLeft">10</b></span>
      <span class="pill">Score: <b id="score">0</b></span>
      <span class="pill">Best: <b id="best">0</b></span>
      <div class="meter" title="Rent Goal">
        <span id="goalFill"></span>
        <div class="label">Rent Goal: <b id="goalNow">0</b> / <b id="goalMax">120</b></div>
      </div>
    </div>

    <canvas id="game" width="540" height="880" aria-label="Coin Flip Frenzy Canvas"></canvas>

    <div class="help">
      <b>How to Play:</b> Move the <span class="kbd">A</span>/<span class="kbd">D</span> keys (or mouse/touch) to aim across the top bar and press
      <span class="kbd">Space</span> (or click <i>Drop</i>) to release a coin. It bounces through pegs (üçï, üí∏, üòº)
      into the <b>Rent Jar</b> at the bottom. Jar = +15. Miss = 0. Hit streaks add bonus! Reach the rent goal before you run out of coins.
    </div>
  </div>

  <div class="watermark">RENT DUE ‚Ä¢ Ms. Bertha is watching üëÄ</div>

  <!-- Character image only, no video -->
  <img id="characterImg" src="Danny coin drop.png" style="display:none; border:none; outline:none; box-shadow:none;" />

<script>
(() => {
  // ====== CONFIG ======
  const cfg = {
    gravity: 1700,           // px/s^2
    air: 0.000,              // air drag per second (kept near zero for snappy feel)
    coinRadius: 24,          // larger coin
    pegRadius: 14,           // larger pegs
    pegRestitution: 0.86,    // bounciness on pegs
    wallRestitution: 0.7,
    floorRestitution: 0.35,
    maxPegRows: 10,          // more rows for bigger board
    pegXSpacing: 90,         // more spacing
    pegYSpacing: 90,
    leftPadding: 60,
    topPadding: 180,
    jarWidth: 200,           // larger jar
    jarMouthWidth: 160,
    jarHeight: 180,
    jarThick: 18,
    coinsPerGame: 10,
    jarScore: 15,
    rentGoal: 120,
    aimSpeed: 700,           // faster aim for bigger board
    pegEmoji: ["üçï","üí∏","üòº","üçï","üí∏","üòº"],
    streakBonus: [0, 0, 2, 5, 10, 15], // bonus for consecutive hits
    missShake: 7,
    hitConfetti: 55,
    maxCoinsOnScreen: 1
  };

  // ====== DOM ======
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const dCoins = document.getElementById("coinsLeft");
  const dScore = document.getElementById("score");
  const dBest  = document.getElementById("best");
  const dGoalFill = document.getElementById("goalFill");
  const dGoalNow  = document.getElementById("goalNow");
  const dGoalMax  = document.getElementById("goalMax");
  const btnStart  = document.getElementById("btnStart");
  const btnDrop   = document.getElementById("btnDrop");
  const btnReset  = document.getElementById("btnReset");
  const btnMute   = document.getElementById("btnMute");
  // Character image only
  const characterImg = document.getElementById('characterImg');
  const playerSelect = document.getElementById('playerSelect');

  // Persisted Best Score
  let best = Number(localStorage.getItem("coinfrenzy_best")||0);
  dBest.textContent = best;

  // ====== STATE ======
  const state = {
    running: false,
    lastT: 0,
    aimX: canvas.width/2,
    coinsLeft: cfg.coinsPerGame,
    score: 0,
    streak: 0,
    goal: 0,
    worldShake: 0,
    muted: false,
    keys: new Set(),
    coins: [],
    pegs: [],
    particles: [],
    jar: null
  };

  // ====== AUDIO (WebAudio minimal, no files) ======
  const AudioKit = (() => {
    const ACtx = window.AudioContext || window.webkitAudioContext;
    const ctx = new ACtx();
    const vol = ctx.createGain();
    vol.gain.value = 0.25;
    vol.connect(ctx.destination);

    const beep = (freq=440, dur=0.09, type="sine", v=0.35) => {
      if (state.muted) return;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = v;
      o.connect(g); g.connect(vol);
      const t = ctx.currentTime;
      o.start(t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      o.stop(t + dur + 0.05);
    };

    return { ctx, beep };
  })();

  // ====== WORLD SETUP ======
  function resetWorld() {
    state.running = false;
    state.lastT = 0;
    state.aimX = canvas.width/2;
    state.coinsLeft = cfg.coinsPerGame;
    state.score = 0;
    state.goal = 0;
    state.streak = 0;
    state.worldShake = 0;
    state.coins = [];
    state.particles = [];
    state.pegs = buildPegs();
    state.jar = buildJar();
    updateHUD();
    draw(0);
  }

  function buildPegs() {
    const pegs = [];
    const W = canvas.width;
    for (let row = 0; row < cfg.maxPegRows; row++) {
      const y = cfg.topPadding + row * cfg.pegYSpacing;
      const count = Math.floor((W - cfg.leftPadding*2) / cfg.pegXSpacing);
      const offset = (row % 2 === 0) ? 0 : cfg.pegXSpacing/2;
      for (let i=0;i<=count;i++){
        const x = cfg.leftPadding + offset + i*cfg.pegXSpacing;
        if (x < cfg.leftPadding || x > W - cfg.leftPadding) continue;
        const emoji = cfg.pegEmoji[(row + i) % cfg.pegEmoji.length];
        pegs.push({x, y, r: cfg.pegRadius, e: cfg.pegRestitution, emoji});
      }
    }
    return pegs;
  }

  function buildJar() {
    const x = canvas.width/2;
    const floor = canvas.height - 28;
    return {
      x,
      floor,
      w: cfg.jarWidth,
      mouth: cfg.jarMouthWidth,
      h: cfg.jarHeight,
      thick: cfg.jarThick
    };
  }

  // ====== VIDEO DROP STATE ======
  let isCoinDropVideoPlaying = false;
  let pendingCoinDropX = null;

  // ====== INPUT ======
  canvas.addEventListener("pointermove", e => {
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) / rect.width * canvas.width;
    state.aimX = clamp(px, 24, canvas.width-24);
  }, {passive:true});

  canvas.addEventListener("pointerdown", () => maybeDrop());
  btnDrop.addEventListener("click", () => maybeDrop());
  btnStart.addEventListener("click", () => startGame());
  btnReset.addEventListener("click", () => resetWorld());
  btnMute.addEventListener("click", () => {
    state.muted = !state.muted;
    btnMute.textContent = state.muted ? "üîá Sound: Off" : "üîä Sound: On";
    if (!state.muted) AudioKit.beep(660,.06,"triangle",0.2);
  });

  window.addEventListener("keydown", (e)=>{
    state.keys.add(e.key.toLowerCase());
    if (e.key === " "){ e.preventDefault(); maybeDrop(); }
  });
  window.addEventListener("keyup", (e)=> state.keys.delete(e.key.toLowerCase()));

  // ====== PLAYER SELECTION ======
  playerSelect.addEventListener('change', function() {
    characterImg.src = this.value;
  });

  // ====== GAME LOOP ======
  function startGame(){
    if (state.running) return;
    state.running = true;
    state.lastT = performance.now();
    requestAnimationFrame(loop);
  }

  function loop(t){
    if (!state.running) return;
    const dt = Math.min(0.02, (t - state.lastT)/1000);
    state.lastT = t;

    // Keyboard aim
    const aimVel = (state.keys.has("a") || state.keys.has("arrowleft") ? -1 : 0)
                 + (state.keys.has("d") || state.keys.has("arrowright") ? 1 : 0);
    if (aimVel !== 0) {
      state.aimX = clamp(state.aimX + aimVel*cfg.aimSpeed*dt, 24, canvas.width-24);
    }

    physics(dt);
    draw(dt);

    requestAnimationFrame(loop);
  }

  // ====== PHYSICS ======
  function physics(dt){
    // Update coins
    for (let i=state.coins.length-1; i>=0; i--){
      const c = state.coins[i];
      if (c.dead) { state.coins.splice(i,1); continue; }

      // Integrate
      c.vy += cfg.gravity * dt;
      c.vx *= (1 - cfg.air*dt);
      c.vy *= (1 - cfg.air*dt);
      c.x  += c.vx * dt;
      c.y  += c.vy * dt;

      // Peg collisions
      for (let p of state.pegs){
        const dx = c.x - p.x;
        const dy = c.y - p.y;
        const dist = Math.hypot(dx, dy);
        const minD = c.r + p.r;
        if (dist < minD){
          // push out
          const nx = dx / (dist || 1e-6);
          const ny = dy / (dist || 1e-6);
          const overlap = (minD - dist) + 0.5;
          c.x += nx * overlap;
          c.y += ny * overlap;
          // reflect velocity
          const vn = c.vx*nx + c.vy*ny; // speed along normal
          if (vn < 0){
            const e = p.e;
            c.vx = c.vx - (1+e)*vn*nx;
            c.vy = c.vy - (1+e)*vn*ny;
            // slight randomness to avoid perfect symmetry
            c.vx += (Math.random() - 0.5) * 40;
          }
          // peg ding
          if (c.hitCooldown <= 0){
            AudioKit.beep(880+Math.random()*120, .04, "square", 0.2);
            c.hitCooldown = 0.03;
          }
        }
      }
      c.hitCooldown = Math.max(0, c.hitCooldown - dt);

      // Walls
      if (c.x < c.r){
        c.x = c.r; c.vx = -c.vx * cfg.wallRestitution;
      } else if (c.x > canvas.width - c.r){
        c.x = canvas.width - c.r; c.vx = -c.vx * cfg.wallRestitution;
      }

      // Jar detection & floor
      const j = state.jar;
      const jarTop = j.floor - j.h;
      const mouthL = j.x - j.mouth/2;
      const mouthR = j.x + j.mouth/2;

      // Entering jar mouth (from above)
      if (!c.scored && c.y + c.r >= jarTop && c.y + c.r < jarTop + 24 && c.x > mouthL && c.x < mouthR){
        // It's going in ‚Äî guide it softly down inside the jar
        c.insideJar = true;
        c.vx *= 0.4;
        AudioKit.beep(660,.08,"triangle",0.25);
      }

      if (c.insideJar){
        // Inside jar walls
        const innerL = j.x - (j.w/2 - j.thick);
        const innerR = j.x + (j.w/2 - j.thick);
        if (c.x - c.r < innerL){ c.x = innerL + c.r; c.vx = Math.abs(c.vx)*0.4; }
        if (c.x + c.r > innerR){ c.x = innerR - c.r; c.vx = -Math.abs(c.vx)*0.4; }
        // Bottom of jar
        const jarBottom = j.floor - j.thick - 4;
        if (c.y + c.r >= jarBottom){
          c.y = jarBottom - c.r;
          c.vx *= 0.3; c.vy *= -cfg.floorRestitution;
          // celebration sound when coin lands in jar
          if (!c.scored && Math.abs(c.vy) < 60){
            // award score
            c.scored = true;
            state.streak += 1;
            state.score += 15;
            state.goal += 15;
            spawnConfetti(c.x, c.y, cfg.hitConfetti);
            state.worldShake += 3;
            AudioKit.beep(520,.05,"square",0.30);
            setTimeout(()=>AudioKit.beep(780,.09,"triangle",0.22), 45);
            if (state.goal >= cfg.rentGoal){
              // Win! brief celebration
              spawnConfetti(state.jar.x, state.jar.floor - state.jar.h + 10, 120);
              AudioKit.beep(880,.09,"sawtooth",0.28);
              AudioKit.beep(990,.12,"sawtooth",0.26);
            }
            updateHUD();
            // let coin settle, then remove
            setTimeout(()=>{ c.dead = true; }, 450);
          }
        }
      } else {
        // Regular floor
        if (c.y + c.r >= j.floor){
          c.y = j.floor - c.r;
          // small bounce once
          if (!c.landed){
            c.vy *= -cfg.floorRestitution;
            c.vx *= 0.7;
            c.landed = true;
          } else {
            c.vy = 0; c.vx *= 0.94;
            if (Math.abs(c.vx) < 8){
              // miss ‚Äî coin stops
              if (!c.scored){
                state.streak = 0;
                AudioKit.beep(220,.05,"sine",0.12);
                state.worldShake += 1.5;
                updateHUD();
              }
              c.dead = true;
            }
          }
        }
      }
    }

    // World shake decay
    state.worldShake *= 0.9;

    // Particles
    for (let i=state.particles.length-1;i>=0;i--){
      const p = state.particles[i];
      p.vx += p.ax*dt; p.vy += p.ay*dt;
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.life -= dt;
      if (p.life <= 0) state.particles.splice(i,1);
    }
  }

  function onJarScore(c){
    // Only handle confetti, sound, and win celebration, not scoring
    // (scoring is handled in physics above)
    // This function is now a no-op or can be removed if not used elsewhere
  }

  function onMiss(c){
    state.streak = 0;
    // soft thunk
    AudioKit.beep(220,.05,"sine",0.12);
    state.worldShake += 1.5;
    updateHUD();
  }

  // ====== COIN DROP LOGIC (no video) ======
  function maybeDrop() {
    if (!state.running) startGame();
    if (state.coins.length >= cfg.maxCoinsOnScreen) return;
    if (state.coinsLeft <= 0) return;
    dropCoinAtX(state.aimX);
  }
  function dropCoinAtX(x) {
    state.coinsLeft--;
    updateHUD();
    const y = 40; // starting Y for the coin
    const c = {
      x, y,
      vx: (Math.random()-0.5)*80,
      vy: 0,
      r: cfg.coinRadius,
      color1: "#f8d06a",
      color2: "#caa23a",
      hitCooldown: 0,
      landed: false,
      scored: false,
      insideJar: false,
      dead: false
    };
    state.coins.push(c);
    AudioKit.beep(400,.06,"triangle",0.2);
  }

  // ====== SPAWNERS ======
  function spawnConfetti(x, y, n=60){
    for (let i=0;i<n;i++){
      const a = Math.random()*Math.PI*2;
      const s = 200 + Math.random()*320;
      state.particles.push({
        x, y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s - 200,
        ax: 0, ay: 900,
        life: 0.8 + Math.random()*0.6,
        size: 2 + Math.random()*3
      });
    }
  }

  // ====== RENDER ======
  function draw(dt){
    const shakeX = (Math.random()*2-1) * state.worldShake;
    const shakeY = (Math.random()*2-1) * state.worldShake;

    ctx.save();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.translate(shakeX, shakeY);

    // Backdrop grid
    drawBackdrop();

    // Draw character image above the board, following aim
    const charWidth = 120, charHeight = 140, charY = 10;
    if (characterImg.complete) {
      ctx.drawImage(characterImg, state.aimX - charWidth/2, charY, charWidth, charHeight);
    }

    // Aim line
    drawAim();

    // Pegs (with emojis)
    for (let p of state.pegs){
      drawPeg(p);
    }

    // Jar
    drawJar(state.jar);

    // Coins
    for (let c of state.coins){
      drawCoin(c);
    }

    // Particles
    for (let p of state.particles){
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = randomRibbonColor(p.seed);
      ctx.fillRect(p.x, p.y, p.size, p.size*2);
      ctx.globalAlpha = 1;
    }

    // Overlay text if out of coins
    if (state.coinsLeft <= 0 && state.coins.length === 0){
      drawGameOver();
    }

    ctx.restore();
  }

  function drawBackdrop(){
    const W = canvas.width, H = canvas.height;
    // Wooden background
    const wood = ctx.createLinearGradient(0, 0, 0, H);
    wood.addColorStop(0, "#c49e6c");
    wood.addColorStop(0.5, "#a97c50");
    wood.addColorStop(1, "#7b5832");
    ctx.fillStyle = wood;
    ctx.fillRect(0,0,W,H);
    // Subtle wood grain lines
    ctx.save();
    ctx.globalAlpha = 0.13;
    for (let y = 0; y < H; y += 32) {
      ctx.beginPath();
      ctx.moveTo(0, y + 8*Math.sin(y/60));
      for (let x = 0; x < W; x += 40) {
        ctx.lineTo(x, y + 8*Math.sin((x+y)/80));
      }
      ctx.strokeStyle = '#6b4a23';
      ctx.lineWidth = 2.2;
      ctx.stroke();
    }
    ctx.restore();
    // Wooden frame
    ctx.save();
    ctx.lineWidth = 22;
    ctx.strokeStyle = '#8b6a3a';
    ctx.strokeRect(11, 11, W-22, H-22);
    ctx.lineWidth = 7;
    ctx.strokeStyle = '#e2c28b';
    ctx.strokeRect(22, 22, W-44, H-44);
    ctx.restore();
    // Floor (darker wood)
    ctx.fillStyle = "#6b4a23";
    ctx.fillRect(0, state.jar.floor, W, H - state.jar.floor);
    // Floor line
    ctx.strokeStyle = "#a97c50";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, state.jar.floor+0.5);
    ctx.lineTo(W, state.jar.floor+0.5);
    ctx.stroke();
  }

  function drawAim(){
    // top bar
    ctx.strokeStyle = "#2a2f57";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(10, 60);
    ctx.lineTo(canvas.width-10, 60);
    ctx.stroke();

    // aim guide
    ctx.fillStyle = "#7cc3ff";
    ctx.beginPath();
    ctx.arc(state.aimX, 60, 7, 0, Math.PI*2);
    ctx.fill();

    // dotted drop line
    ctx.setLineDash([6,8]);
    ctx.strokeStyle = "rgba(124,195,255,.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(state.aimX, 70);
    ctx.lineTo(state.aimX, state.jar.floor - state.jar.h - 20);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawPeg(p){
    // Wooden peg body
    ctx.save();
    const grad = ctx.createRadialGradient(p.x-2,p.y-2,1,p.x,p.y, p.r+2);
    grad.addColorStop(0,"#ffe2b0");
    grad.addColorStop(0.7,"#c49e6c");
    grad.addColorStop(1,"#7b5832");
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    // Peg highlight
    ctx.globalAlpha = 0.18;
    ctx.beginPath(); ctx.arc(p.x-p.r/3,p.y-p.r/3,p.r/2,0,Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
    ctx.globalAlpha = 1;
    // Peg shadow
    ctx.globalAlpha = 0.18;
    ctx.beginPath(); ctx.arc(p.x+p.r/2,p.y+p.r/2,p.r/1.7,0,Math.PI*2); ctx.fillStyle = '#000'; ctx.fill();
    ctx.globalAlpha = 1;
    // Emoji label (decorative)
    ctx.font = "18px system-ui, apple color emoji, segoe ui emoji";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.globalAlpha = 0.9;
    ctx.fillText(p.emoji, p.x, p.y - p.r - 8);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawJar(j){
    // Realistic glass jar drawing
    ctx.save();
    ctx.translate(j.x, j.floor - j.h);
    const W = j.w, H = j.h, T = j.thick;
    // Jar shadow
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(0, H-6, W*0.38, 16, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    // Jar body (curved)
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(-W/2+T, 18);
    ctx.bezierCurveTo(-W/2, H*0.18, -W/2, H*0.82, -W/2+T, H-T);
    ctx.bezierCurveTo(-W/2+T, H, W/2-T, H, W/2-T, H-T);
    ctx.bezierCurveTo(W/2, H*0.82, W/2, H*0.18, W/2-T, 18);
    ctx.closePath();
    ctx.fillStyle = "rgba(71,209,106,0.13)";
    ctx.fill();
    ctx.lineWidth = 3.5;
    ctx.strokeStyle = "#3fc46e";
    ctx.stroke();
    ctx.restore();
    // Jar base
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(0, H-8, W*0.38, 12, 0, 0, Math.PI*2);
    ctx.fillStyle = "rgba(71,209,106,0.22)";
    ctx.fill();
    ctx.restore();
    // Jar mouth (opening, with highlight)
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(0, 0, cfg.jarMouthWidth/2, T/1.7, 0, 0, Math.PI*2);
    ctx.fillStyle = "#e8fff2";
    ctx.globalAlpha = 0.18;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "#3fc46e";
    ctx.lineWidth = 2.5;
    ctx.stroke();
    ctx.restore();
    // Jar lid
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(0, -T/1.5, cfg.jarMouthWidth/2.1, T/2.2, 0, 0, Math.PI*2);
    ctx.fillStyle = "#b7e3c7";
    ctx.globalAlpha = 0.32;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "#a7cfc0";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
    // Jar highlight
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(-W/4, H*0.18);
    ctx.bezierCurveTo(-W/4+8, H*0.3, -W/4+8, H*0.7, -W/4, H*0.82);
    ctx.lineWidth = 4.5;
    ctx.strokeStyle = "rgba(255,255,255,0.13)";
    ctx.stroke();
    ctx.restore();
    // Label
    ctx.fillStyle = "#c8ffd9";
    ctx.font = "bold 22px ui-sans-serif, system-ui";
    ctx.textAlign = "center";
    ctx.fillText("RENT JAR", 0, H/2);
    ctx.restore();
  }

  function drawCoin(c){
    // Wooden coin (homemade look)
    ctx.save();
    const g = ctx.createRadialGradient(c.x-6, c.y-8, 4, c.x, c.y, c.r+4);
    g.addColorStop(0, "#ffe2b0");
    g.addColorStop(0.5, "#e2c28b");
    g.addColorStop(1, "#a97c50");
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill();
    // Coin rim
    ctx.strokeStyle = "#7b5832";
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.arc(c.x,c.y,c.r-1,0,Math.PI*2); ctx.stroke();
    // Coin wood grain
    ctx.globalAlpha = 0.18;
    for (let i=0; i<3; ++i) {
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r-4-i*3, Math.PI*0.2, Math.PI*1.7);
      ctx.strokeStyle = '#6b4a23';
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    // Rent $ emboss
    ctx.fillStyle = "#7b5832";
    ctx.font = "bold 16px ui-sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("$", c.x, c.y);
    ctx.restore();
  }

  function drawGameOver(){
    const W = canvas.width, H = canvas.height;
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.45)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "#e8eefc";
    ctx.font = "bold 28px ui-sans-serif, system-ui";
    ctx.textAlign = "center";
    ctx.fillText("Out of Coins!", W/2, H*0.35);
    ctx.font = "18px ui-sans-serif, system-ui";
    const msg = state.goal >= cfg.rentGoal ? "üèÜ Rent paid! Ms. Bertha is (temporarily) pleased." : "You came up short. Try again!";
    ctx.fillText(msg, W/2, H*0.35 + 34);
    ctx.font = "bold 16px ui-sans-serif";
    ctx.fillStyle = "#a7b5dd";
    ctx.fillText("Press ‚ñ∂ Start or ‚ü≤ Reset", W/2, H*0.35 + 62);
    ctx.restore();
  }

  // ====== UTIL ======
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if (w < 2*r) r = w/2;
    if (h < 2*r) r = h/2;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function randomRibbonColor(seed){
    // simple pleasing palette
    const colors = ["#72ffa6", "#7cc3ff", "#ffd166", "#ff82c9", "#9afff1"];
    return colors[Math.floor(Math.random()*colors.length)];
  }

  function updateHUD(){
    // Show 0 instead of NaN
    function safeNum(val) {
      return (typeof val === 'number' && !isNaN(val)) ? val : 0;
    }
    dCoins.textContent = safeNum(state.coinsLeft);
    dScore.textContent = safeNum(state.score);
    dGoalNow.textContent = safeNum(state.goal);
    dGoalMax.textContent = safeNum(cfg.rentGoal);
    const pct = clamp((safeNum(state.goal) / safeNum(cfg.rentGoal))*100, 0, 100);
    dGoalFill.style.width = pct + "%";
    // update best
    if (state.score > best){
      best = state.score;
      localStorage.setItem("coinfrenzy_best", String(best));
      dBest.textContent = safeNum(best);
    } else {
      dBest.textContent = safeNum(best);
    }
  }

  // ====== RESPONSIVE CANVAS (keeps aspect, crisp physics) ======
  function resize(){
    // Larger default canvas for bigger board
    const targetW = Math.min(820, Math.floor(window.innerWidth - 28));
    const targetH = Math.floor(targetW * (16/9));
    const ratio = window.devicePixelRatio || 1;
    canvas.style.width = targetW + "px";
    canvas.style.height = targetH + "px";
    canvas.width = Math.floor(targetW * ratio);
    canvas.height = Math.floor(targetH * ratio);
    ctx.setTransform(ratio,0,0,ratio,0,0);

    // Rebuild world with new dimensions while preserving HUD stats
    const saved = {
      running: state.running,
      coinsLeft: state.coinsLeft,
      score: state.score,
      goal: state.goal,
      streak: state.streak,
      muted: state.muted
    };
    state.pegs = buildPegs();
    state.jar = buildJar();
    state.coins = [];
    state.particles = [];
    state.aimX = canvas.width/2;

    Object.assign(state, saved);
    updateHUD();
    draw(0);
  }
  window.addEventListener("resize", resize);

  // ====== INIT ======
  dGoalMax.textContent = cfg.rentGoal;
  resetWorld();
  resize(); // set initial responsive size

  // ====== QUALITY OF LIFE ======
  // clarify hotkey label for mobile/desktop
  document.getElementById("hotkey").textContent = /Mobi|Android/i.test(navigator.userAgent) ? "Tap" : "Space";
})();
</script>
</body>
</html>
