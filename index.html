<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rent Due — Coin Flip Frenzy</title>
<style>
  :root{
    --bg:#0f1220;
    --ink:#e9ecf2;
    --accent:#72ffa6;
    --accent-2:#7cc3ff;
    --bad:#ff6b6b;
    --warn:#ffd166;
    --jar:#47d16a;
    --panel:#171b30;
    --panel-2:#111425;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 60% 15%, #1a2040 0%, #0c0f1c 60%, #080a14 100%); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";}

  .wrap{
    max-width: 980px;
    margin: 0 auto;
    padding: 14px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  header{
    display:flex; align-items:center; justify-content:space-between; gap:12px;
  }
  h1{
    margin:0; font-weight:800; letter-spacing:.5px;
    font-size: clamp(18px, 2.6vw, 28px);
    display:flex; align-items:center; gap:10px;
  }
  h1 .tag {font-size:.78em; font-weight:700; padding:4px 9px; border-radius:999px; background:linear-gradient(180deg,var(--panel),var(--panel-2)); border:1px solid #22263f; color:#9ab;}
  .controls{
    display:flex; gap:8px; flex-wrap:wrap;
  }
  button, .toggle{
    background: linear-gradient(180deg,#1b2143,#141a36);
    border: 1px solid #2a2f57; color:#e9ecf2;
    padding:10px 14px; border-radius:12px; font-weight:700;
    cursor:pointer; outline:none;
    box-shadow: 0 1px 0 #000 inset, 0 0 0 0 rgba(0,0,0,.2);
    transform: translateZ(0);
  }
  button:hover{filter:brightness(1.08)}
  button.primary{background:linear-gradient(180deg,#2c865a,#1c6f49); border-color:#2b9c68}
  button.warn{background:linear-gradient(180deg,#7a1f1f,#611515); border-color:#9c3838}
  .hud{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    background:linear-gradient(180deg,var(--panel),var(--panel-2));
    border:1px solid #252a4a; padding:10px 12px; border-radius:14px;
  }
  .pill{
    padding:6px 10px; border-radius:999px; background:#0e1226; border:1px solid #23284a; color:#c8d2eb; font-weight:700; letter-spacing:.2px;
  }
  .meter{
    flex:1 1 280px; background:#0b0f22; border:1px solid #1e2444; border-radius:10px; height:14px; position:relative; overflow:hidden;
  }
  .meter>span{position:absolute; left:0; top:0; bottom:0; background:linear-gradient(90deg,#34d399,#22c55e); width:0%;}
  .meter .label{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:12px; color:#a8b2d8; pointer-events:none; mix-blend-mode:screen}

  canvas{
    width:100%; height:auto; border-radius:16px;
    background: linear-gradient(180deg, #0b1025, #090d1e 38%, #070a16);
    border:1px solid #222647; box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 120px rgba(21,28,64,.6);
    touch-action:none;
  }

  .help{
    font-size:14px; color:#b7c1e0;
    background:linear-gradient(180deg,var(--panel),var(--panel-2));
    border:1px solid #252a4a; padding:10px 12px; border-radius:14px;
  }

  .kbd{padding:2px 6px;border-radius:6px;background:#0c1030;border:1px solid #293059;font-weight:800}

  .watermark{
    position:fixed; right:12px; bottom:10px; opacity:.45; font-weight:800; letter-spacing:.8px; font-size:12px;
  }

  @media (max-width:560px){
    .controls{gap:6px}
    button{padding:8px 10px}
    .hud{gap:6px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>🪙 Rent Due <span class="tag">Coin Flip Frenzy</span></h1>
      <div class="controls">
        <button id="btnStart" class="primary">▶ Start</button>
        <button id="btnDrop">🪙 Drop (<span id="hotkey">Space</span>)</button>
        <button id="btnReset" class="warn">⟲ Reset</button>
        <button id="btnMute" class="toggle">🔊 Sound: On</button>
      </div>
    </header>

    <div class="hud">
      <span class="pill">Coins left: <b id="coinsLeft">10</b></span>
      <span class="pill">Score: <b id="score">0</b></span>
      <span class="pill">Best: <b id="best">0</b></span>
      <div class="meter" title="Rent Goal">
        <span id="goalFill"></span>
        <div class="label">Rent Goal: <b id="goalNow">0</b> / <b id="goalMax">120</b></div>
      </div>
    </div>

    <canvas id="game" width="540" height="880" aria-label="Coin Flip Frenzy Canvas"></canvas>

    <div class="help">
      <b>How to Play:</b> Move the <span class="kbd">A</span>/<span class="kbd">D</span> keys (or mouse/touch) to aim across the top bar and press
      <span class="kbd">Space</span> (or click <i>Drop</i>) to release a coin. It bounces through pegs (🍕, 💸, 😼)
      into the <b>Rent Jar</b> at the bottom. Jar = +15. Miss = 0. Hit streaks add bonus! Reach the rent goal before you run out of coins.
    </div>
  </div>

  <div class="watermark">RENT DUE • Ms. Bertha is watching 👀</div>

<script>
(() => {
  // ====== CONFIG ======
  const cfg = {
    gravity: 1700,           // px/s^2
    air: 0.000,              // air drag per second (kept near zero for snappy feel)
    coinRadius: 14,
    pegRadius: 8,
    pegRestitution: 0.86,    // bounciness on pegs
    wallRestitution: 0.7,
    floorRestitution: 0.35,
    maxPegRows: 9,
    pegXSpacing: 60,
    pegYSpacing: 64,
    leftPadding: 40,
    topPadding: 140,
    jarWidth: 140,
    jarMouthWidth: 110,
    jarHeight: 120,
    jarThick: 14,
    coinsPerGame: 10,
    jarScore: 15,
    rentGoal: 120,
    aimSpeed: 550,           // keyboard aim speed (px per second)
    pegEmoji: ["🍕","💸","😼","🍕","💸","😼"],
    streakBonus: [0, 0, 2, 5, 10, 15], // bonus for consecutive hits
    missShake: 7,
    hitConfetti: 55,
    maxCoinsOnScreen: 1
  };

  // ====== DOM ======
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const dCoins = document.getElementById("coinsLeft");
  const dScore = document.getElementById("score");
  const dBest  = document.getElementById("best");
  const dGoalFill = document.getElementById("goalFill");
  const dGoalNow  = document.getElementById("goalNow");
  const dGoalMax  = document.getElementById("goalMax");
  const btnStart  = document.getElementById("btnStart");
  const btnDrop   = document.getElementById("btnDrop");
  const btnReset  = document.getElementById("btnReset");
  const btnMute   = document.getElementById("btnMute");

  // Persisted Best Score
  let best = Number(localStorage.getItem("coinfrenzy_best")||0);
  dBest.textContent = best;

  // ====== STATE ======
  const state = {
    running: false,
    lastT: 0,
    aimX: canvas.width/2,
    coinsLeft: cfg.coinsPerGame,
    score: 0,
    streak: 0,
    goal: 0,
    worldShake: 0,
    muted: false,
    keys: new Set(),
    coins: [],
    pegs: [],
    particles: [],
    jar: null
  };

  // ====== AUDIO (WebAudio minimal, no files) ======
  const AudioKit = (() => {
    const ACtx = window.AudioContext || window.webkitAudioContext;
    const ctx = new ACtx();
    const vol = ctx.createGain();
    vol.gain.value = 0.25;
    vol.connect(ctx.destination);

    const beep = (freq=440, dur=0.09, type="sine", v=0.35) => {
      if (state.muted) return;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = v;
      o.connect(g); g.connect(vol);
      const t = ctx.currentTime;
      o.start(t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      o.stop(t + dur + 0.05);
    };

    return { ctx, beep };
  })();

  // ====== WORLD SETUP ======
  function resetWorld() {
    state.running = false;
    state.lastT = 0;
    state.aimX = canvas.width/2;
    state.coinsLeft = cfg.coinsPerGame;
    state.score = 0;
    state.goal = 0;
    state.streak = 0;
    state.worldShake = 0;
    state.coins = [];
    state.particles = [];
    state.pegs = buildPegs();
    state.jar = buildJar();
    updateHUD();
    draw(0);
  }

  function buildPegs() {
    const pegs = [];
    const W = canvas.width;
    for (let row = 0; row < cfg.maxPegRows; row++) {
      const y = cfg.topPadding + row * cfg.pegYSpacing;
      const count = Math.floor((W - cfg.leftPadding*2) / cfg.pegXSpacing);
      const offset = (row % 2 === 0) ? 0 : cfg.pegXSpacing/2;
      for (let i=0;i<=count;i++){
        const x = cfg.leftPadding + offset + i*cfg.pegXSpacing;
        if (x < cfg.leftPadding || x > W - cfg.leftPadding) continue;
        const emoji = cfg.pegEmoji[(row + i) % cfg.pegEmoji.length];
        pegs.push({x, y, r: cfg.pegRadius, e: cfg.pegRestitution, emoji});
      }
    }
    return pegs;
  }

  function buildJar() {
    const x = canvas.width/2;
    const floor = canvas.height - 28;
    return {
      x,
      floor,
      w: cfg.jarWidth,
      mouth: cfg.jarMouthWidth,
      h: cfg.jarHeight,
      thick: cfg.jarThick
    };
  }

  // ====== INPUT ======
  canvas.addEventListener("pointermove", e => {
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) / rect.width * canvas.width;
    state.aimX = clamp(px, 24, canvas.width-24);
  }, {passive:true});

  canvas.addEventListener("pointerdown", () => maybeDrop());
  btnDrop.addEventListener("click", () => maybeDrop());
  btnStart.addEventListener("click", () => startGame());
  btnReset.addEventListener("click", () => resetWorld());
  btnMute.addEventListener("click", () => {
    state.muted = !state.muted;
    btnMute.textContent = state.muted ? "🔇 Sound: Off" : "🔊 Sound: On";
    if (!state.muted) AudioKit.beep(660,.06,"triangle",0.2);
  });

  window.addEventListener("keydown", (e)=>{
    state.keys.add(e.key.toLowerCase());
    if (e.key === " "){ e.preventDefault(); maybeDrop(); }
  });
  window.addEventListener("keyup", (e)=> state.keys.delete(e.key.toLowerCase()));

  // ====== GAME LOOP ======
  function startGame(){
    if (state.running) return;
    state.running = true;
    state.lastT = performance.now();
    requestAnimationFrame(loop);
  }

  function loop(t){
    if (!state.running) return;
    const dt = Math.min(0.02, (t - state.lastT)/1000);
    state.lastT = t;

    // Keyboard aim
    const aimVel = (state.keys.has("a") || state.keys.has("arrowleft") ? -1 : 0)
                 + (state.keys.has("d") || state.keys.has("arrowright") ? 1 : 0);
    if (aimVel !== 0) {
      state.aimX = clamp(state.aimX + aimVel*cfg.aimSpeed*dt, 24, canvas.width-24);
    }

    physics(dt);
    draw(dt);

    requestAnimationFrame(loop);
  }

  // ====== PHYSICS ======
  function physics(dt){
    // Update coins
    for (let i=state.coins.length-1; i>=0; i--){
      const c = state.coins[i];
      if (c.dead) { state.coins.splice(i,1); continue; }

      // Integrate
      c.vy += cfg.gravity * dt;
      c.vx *= (1 - cfg.air*dt);
      c.vy *= (1 - cfg.air*dt);
      c.x  += c.vx * dt;
      c.y  += c.vy * dt;

      // Peg collisions
      for (let p of state.pegs){
        const dx = c.x - p.x;
        const dy = c.y - p.y;
        const dist = Math.hypot(dx, dy);
        const minD = c.r + p.r;
        if (dist < minD){
          // push out
          const nx = dx / (dist || 1e-6);
          const ny = dy / (dist || 1e-6);
          const overlap = (minD - dist) + 0.5;
          c.x += nx * overlap;
          c.y += ny * overlap;
          // reflect velocity
          const vn = c.vx*nx + c.vy*ny; // speed along normal
          if (vn < 0){
            const e = p.e;
            c.vx = c.vx - (1+e)*vn*nx;
            c.vy = c.vy - (1+e)*vn*ny;
            // slight randomness to avoid perfect symmetry
            c.vx += (Math.random() - 0.5) * 40;
          }
          // peg ding
          if (c.hitCooldown <= 0){
            AudioKit.beep(880+Math.random()*120, .04, "square", 0.2);
            c.hitCooldown = 0.03;
          }
        }
      }
      c.hitCooldown = Math.max(0, c.hitCooldown - dt);

      // Walls
      if (c.x < c.r){
        c.x = c.r; c.vx = -c.vx * cfg.wallRestitution;
      } else if (c.x > canvas.width - c.r){
        c.x = canvas.width - c.r; c.vx = -c.vx * cfg.wallRestitution;
      }

      // Jar detection & floor
      const j = state.jar;
      const jarTop = j.floor - j.h;
      const mouthL = j.x - j.mouth/2;
      const mouthR = j.x + j.mouth/2;

      // Entering jar mouth (from above)
      if (!c.scored && c.y + c.r >= jarTop && c.y + c.r < jarTop + 24 && c.x > mouthL && c.x < mouthR){
        // It's going in — guide it softly down inside the jar
        c.insideJar = true;
        c.vx *= 0.4;
        AudioKit.beep(660,.08,"triangle",0.25);
      }

      if (c.insideJar){
        // Inside jar walls
        const innerL = j.x - (j.w/2 - j.thick);
        const innerR = j.x + (j.w/2 - j.thick);
        if (c.x - c.r < innerL){ c.x = innerL + c.r; c.vx = Math.abs(c.vx)*0.4; }
        if (c.x + c.r > innerR){ c.x = innerR - c.r; c.vx = -Math.abs(c.vx)*0.4; }
        // Bottom of jar
        const jarBottom = j.floor - j.thick - 4;
        if (c.y + c.r >= jarBottom){
          c.y = jarBottom - c.r;
          c.vx *= 0.3; c.vy *= -cfg.floorRestitution;
          if (!c.scored && Math.abs(c.vy) < 60){
            // award score
            c.scored = true;
            onJarScore(c);
            // let coin settle, then remove
            setTimeout(()=>{ c.dead = true; }, 450);
          }
        }
      } else {
        // Regular floor
        if (c.y + c.r >= j.floor){
          c.y = j.floor - c.r;
          // small bounce once
          if (!c.landed){
            c.vy *= -cfg.floorRestitution;
            c.vx *= 0.7;
            c.landed = true;
          } else {
            c.vy = 0; c.vx *= 0.94;
            if (Math.abs(c.vx) < 8){
              // miss — coin stops
              if (!c.scored){ onMiss(c); }
              c.dead = true;
            }
          }
        }
      }
    }

    // World shake decay
    state.worldShake *= 0.9;

    // Particles
    for (let i=state.particles.length-1;i>=0;i--){
      const p = state.particles[i];
      p.vx += p.ax*dt; p.vy += p.ay*dt;
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.life -= dt;
      if (p.life <= 0) state.particles.splice(i,1);
    }
  }

  function onJarScore(c){
    let bonus = cfg.streakBonus[Math.min(cfg.streak+1, cfg.streakBonus.length-1)];
    state.streak += 1;
    const gain = cfg.jarScore + bonus;
    state.score += gain;
    state.goal += gain;
    spawnConfetti(c.x, c.y, cfg.hitConfetti);
    state.worldShake += 3;
    AudioKit.beep(520,.05,"square",0.30);
    setTimeout(()=>AudioKit.beep(780,.09,"triangle",0.22), 45);
    if (state.goal >= cfg.rentGoal){
      // Win! brief celebration
      spawnConfetti(state.jar.x, state.jar.floor - state.jar.h + 10, 120);
      AudioKit.beep(880,.09,"sawtooth",0.28);
      AudioKit.beep(990,.12,"sawtooth",0.26);
    }
    updateHUD();
  }

  function onMiss(c){
    state.streak = 0;
    // soft thunk
    AudioKit.beep(220,.05,"sine",0.12);
    state.worldShake += 1.5;
    updateHUD();
  }

  // ====== SPAWNERS ======
  function maybeDrop(){
    if (!state.running) startGame();
    if (state.coins.length >= cfg.maxCoinsOnScreen) return;
    if (state.coinsLeft <= 0) return;

    state.coinsLeft--;
    updateHUD();

    const x = state.aimX;
    const y = 40;
    const c = {
      x, y,
      vx: (Math.random()-0.5)*80,
      vy: 0,
      r: cfg.coinRadius,
      color1: "#f8d06a",
      color2: "#caa23a",
      hitCooldown: 0,
      landed: false,
      scored: false,
      insideJar: false,
      dead: false
    };
    state.coins.push(c);
    AudioKit.beep(400,.06,"triangle",0.2);
  }

  function spawnConfetti(x, y, n=60){
    for (let i=0;i<n;i++){
      const a = Math.random()*Math.PI*2;
      const s = 200 + Math.random()*320;
      state.particles.push({
        x, y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s - 200,
        ax: 0, ay: 900,
        life: 0.8 + Math.random()*0.6,
        size: 2 + Math.random()*3
      });
    }
  }

  // ====== RENDER ======
  function draw(dt){
    const shakeX = (Math.random()*2-1) * state.worldShake;
    const shakeY = (Math.random()*2-1) * state.worldShake;

    ctx.save();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.translate(shakeX, shakeY);

    // Backdrop grid
    drawBackdrop();

    // Aim line
    drawAim();

    // Pegs (with emojis)
    for (let p of state.pegs){
      drawPeg(p);
    }

    // Jar
    drawJar(state.jar);

    // Coins
    for (let c of state.coins){
      drawCoin(c);
    }

    // Particles
    for (let p of state.particles){
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = randomRibbonColor(p.seed);
      ctx.fillRect(p.x, p.y, p.size, p.size*2);
      ctx.globalAlpha = 1;
    }

    // Overlay text if out of coins
    if (state.coinsLeft <= 0 && state.coins.length === 0){
      drawGameOver();
    }

    ctx.restore();
  }

  function drawBackdrop(){
    const W = canvas.width, H = canvas.height;
    // soft vignette
    const g = ctx.createRadialGradient(W*0.5, H*0.15, 50, W*0.5, H*0.15, H);
    g.addColorStop(0, "rgba(60,80,130,0.15)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // floor
    ctx.fillStyle = "#0b0f22";
    ctx.fillRect(0, state.jar.floor, W, H - state.jar.floor);
    // floor line
    ctx.strokeStyle = "#20264a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, state.jar.floor+0.5);
    ctx.lineTo(W, state.jar.floor+0.5);
    ctx.stroke();
  }

  function drawAim(){
    // top bar
    ctx.strokeStyle = "#2a2f57";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(10, 60);
    ctx.lineTo(canvas.width-10, 60);
    ctx.stroke();

    // aim guide
    ctx.fillStyle = "#7cc3ff";
    ctx.beginPath();
    ctx.arc(state.aimX, 60, 7, 0, Math.PI*2);
    ctx.fill();

    // dotted drop line
    ctx.setLineDash([6,8]);
    ctx.strokeStyle = "rgba(124,195,255,.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(state.aimX, 70);
    ctx.lineTo(state.aimX, state.jar.floor - state.jar.h - 20);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawPeg(p){
    // peg body
    const grad = ctx.createRadialGradient(p.x-2,p.y-2,1,p.x,p.y, p.r+2);
    grad.addColorStop(0,"#8fa3ff");
    grad.addColorStop(1,"#2b3470");
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();

    // emoji label (decorative)
    ctx.font = "16px system-ui, apple color emoji, segoe ui emoji";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.globalAlpha = 0.9;
    ctx.fillText(p.emoji, p.x, p.y - 18);
    ctx.globalAlpha = 1;
  }

  function drawJar(j){
    // outer body
    ctx.save();
    ctx.translate(j.x, j.floor - j.h);

    // Glass body
    const W = j.w, H = j.h, T = j.thick;
    ctx.fillStyle = "rgba(71,209,106,0.10)";
    ctx.strokeStyle = "#2a9b53";
    ctx.lineWidth = 4;
    // outer
    roundRect(ctx, -W/2, 0, W, H, 16, true, true);
    // inner (glass thickness)
    ctx.globalCompositeOperation = "destination-out";
    roundRect(ctx, -W/2 + T, T, W - 2*T, H - 2*T, 12, true, false);
    // restore for stroke edges
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = "#3fc46e";
    ctx.lineWidth = 2;
    roundRect(ctx, -W/2, 0, W, H, 16, false, true);

    // Jar mouth (opening)
    ctx.fillStyle = "rgba(71,209,106,0.18)";
    roundRect(ctx, -cfg.jarMouthWidth/2, -T/2, cfg.jarMouthWidth, T, 8, true, false);

    // Label
    ctx.fillStyle = "#c8ffd9";
    ctx.font = "bold 18px ui-sans-serif, system-ui";
    ctx.textAlign = "center";
    ctx.fillText("RENT JAR", 0, H/2);

    ctx.restore();
  }

  function drawCoin(c){
    // shiny coin
    const g = ctx.createRadialGradient(c.x-6, c.y-8, 4, c.x, c.y, c.r+4);
    g.addColorStop(0, c.color1);
    g.addColorStop(1, c.color2);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill();

    // rim
    ctx.strokeStyle = "rgba(0,0,0,.25)";
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(c.x,c.y,c.r-1,0,Math.PI*2); ctx.stroke();

    // Rent $ emboss
    ctx.fillStyle = "rgba(60,40,4,.45)";
    ctx.font = "bold 12px ui-sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("$", c.x, c.y);
  }

  function drawGameOver(){
    const W = canvas.width, H = canvas.height;
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.45)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "#e8eefc";
    ctx.font = "bold 28px ui-sans-serif, system-ui";
    ctx.textAlign = "center";
    ctx.fillText("Out of Coins!", W/2, H*0.35);
    ctx.font = "18px ui-sans-serif, system-ui";
    const msg = state.goal >= cfg.rentGoal ? "🏆 Rent paid! Ms. Bertha is (temporarily) pleased." : "You came up short. Try again!";
    ctx.fillText(msg, W/2, H*0.35 + 34);
    ctx.font = "bold 16px ui-sans-serif";
    ctx.fillStyle = "#a7b5dd";
    ctx.fillText("Press ▶ Start or ⟲ Reset", W/2, H*0.35 + 62);
    ctx.restore();
  }

  // ====== UTIL ======
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if (w < 2*r) r = w/2;
    if (h < 2*r) r = h/2;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function randomRibbonColor(seed){
    // simple pleasing palette
    const colors = ["#72ffa6", "#7cc3ff", "#ffd166", "#ff82c9", "#9afff1"];
    return colors[Math.floor(Math.random()*colors.length)];
  }

  function updateHUD(){
    dCoins.textContent = state.coinsLeft;
    dScore.textContent = state.score;
    dGoalNow.textContent = state.goal;
    dGoalMax.textContent = cfg.rentGoal;
    const pct = clamp((state.goal / cfg.rentGoal)*100, 0, 100);
    dGoalFill.style.width = pct + "%";

    // update best
    if (state.score > best){
      best = state.score;
      localStorage.setItem("coinfrenzy_best", String(best));
      dBest.textContent = best;
    }
  }

  // ====== RESPONSIVE CANVAS (keeps aspect, crisp physics) ======
  function resize(){
    // Keep a nice aspect ~ 9:14 (phone-ish) but fill width
    const targetW = Math.min(620, Math.floor(window.innerWidth - 28));
    const targetH = Math.floor(targetW * (14/9));
    const ratio = window.devicePixelRatio || 1;
    canvas.style.width = targetW + "px";
    canvas.style.height = targetH + "px";
    canvas.width = Math.floor(targetW * ratio);
    canvas.height = Math.floor(targetH * ratio);
    ctx.setTransform(ratio,0,0,ratio,0,0);

    // Rebuild world with new dimensions while preserving HUD stats
    const saved = {
      running: state.running,
      coinsLeft: state.coinsLeft,
      score: state.score,
      goal: state.goal,
      streak: state.streak,
      muted: state.muted
    };
    state.pegs = buildPegs();
    state.jar = buildJar();
    state.coins = [];
    state.particles = [];
    state.aimX = canvas.width/2;

    Object.assign(state, saved);
    updateHUD();
    draw(0);
  }
  window.addEventListener("resize", resize);

  // ====== INIT ======
  dGoalMax.textContent = cfg.rentGoal;
  resetWorld();
  resize(); // set initial responsive size

  // ====== QUALITY OF LIFE ======
  // clarify hotkey label for mobile/desktop
  document.getElementById("hotkey").textContent = /Mobi|Android/i.test(navigator.userAgent) ? "Tap" : "Space";
})();
</script>
</body>
</html>
